{
  "articleId": "a-kotlin-di-framework-in-50-lines-and-thoughts-on-kotlin",
  "lang": "en",
  "hash": "a2a93eea3931b29d4bf0f00093b574d737f7bfff4b6cf92e6db787a6f904f306",
  "summaries": [
    {
      "metadata": {
        "summarizer": "azure-ai",
        "model": "DeepSeek-R1"
      },
      "summaries": [
        "The article discusses choosing dependency injection (DI) for small projects, comparing full DI frameworks (verbose) versus factory patterns (clumsy). The author developed a lightweight DI solution using Kotlin’s delegation and classgraph for scanning. Annotations (@Service, @ServiceImpl) mark interfaces and implementations, while a `di()` function delegates dependency resolution, enabling singleton injection with minimal code. Benefits include simplicity, circular dependency support, and dynamic resolution, though limitations include no `init` block usage and lack of advanced features. The author praises Kotlin’s modern features (null checks, lambdas) and how diverse programming paradigms expand problem-solving approaches, emphasizing tools’ influence on design thinking."
      ],
      "startTime": "2025-02-14T13:28:20.958Z",
      "endTime": "2025-02-14T13:28:49.221Z"
    },
    {
      "metadata": {
        "summarizer": "ollama",
        "model": "deepseek-r1:7b"
      },
      "summaries": [
        "The provided code snippet demonstrates a custom Dependency Injection (DI) framework written in Kotlin, designed to simplify dependency management within classes annotated with `<autowired>`. Here's a structured explanation of the key aspects and functionality:\n\n### Key Components of the DI Framework:\n1. **`inj` Function**: This function is used to inject dependencies into an object. It accepts an object implementing `Inj`, which contains two essential functions: `init` for initialization and `get` to retrieve dependencies.\n\n2. **Initialization (`init` Method)**: The `init` method runs first, responsible for setting up any required dependencies before accessing the class's properties or methods. This ensures that all dependencies are available when needed.\n\n3. **Dependencies Retrieval (`get` Function)**: After initialization, the `get` function provides access to the injected dependencies, allowing further method calls on these dependencies as required by child classes.\n\n### Usage and Operation:\n- **Autowiring Annotation**: Classes annotated with `<autowired>` define their methods with `.inj` functions. Each method can specify its name (optional) and a list of types it depends on.\n  \n- **Dynamic Injection**: The DI framework injects dependencies automatically when an object is created, using the `init` function to initialize any further dependencies needed during runtime.\n\n### Example Walkthrough:\nThe example shows multiple classes (`A`, `B`, etc.) with methods annotated by `.inj`. When an instance of class `B` is created, the DI framework injects a dependency of type `A` into it. The initialization order ensures that all necessary dependencies are set up before any method calls.\n\n### Features:\n- **Strict Null Policy**: Using `.strict()` ensures dependencies cannot be null and requires providing default values if none exist.\n  \n- **Modularity and Scalability**: Suitable for small applications, allowing easy addition of dependencies dynamically during runtime.\n\n### Considerations:\n- **Order of Initialization**: The framework enforces the correct order to prevent `NotProvidedException`, ensuring that each method's initialization runs after its dependencies are set up.\n  \n- **Nested Dependencies**: Handles multiple or nested dependencies by chaining the initialization process correctly, provided the order is maintained.\n\n### Comparison with Other DI Frameworks:\nSimilar to AUTOFLAC, this framework allows dynamic injection of dependencies at runtime without compile-time annotations. The strict null policy adds an extra layer of safety compared to other frameworks that might not enforce non-null values consistently.\n\n### Conclusion:\nThis Kotlin-based DI framework offers a lightweight solution for small applications, providing automatic dependency management with a focus on simplicity and safety. Its integration with TornadoFX enhances its utility in embedding JavaFX views within Kotlin code, leveraging strong typing for robust development practices."
      ]
    }
  ]
}